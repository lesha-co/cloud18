<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Subreddit Network Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #1a1a1a;
        overflow: hidden;
      }

      #graph {
        width: 100vw;
        height: 100vh;
      }

      .node {
        cursor: pointer;
        stroke: #fff;
        stroke-width: 1.5px;
      }

      .node:hover {
        stroke-width: 3px;
      }

      .link {
        stroke: #666;
        stroke-opacity: 0.6;
        stroke-width: 1px;
      }

      .link.multi-link {
        stroke: #8888ff;
        stroke-opacity: 0.8;
        stroke-width: 2px;
      }

      .node-label {
        pointer-events: none;
        font-size: 10px;
        fill: #fff;
        text-anchor: middle;
        dominant-baseline: central;
        text-shadow:
          0 0 3px #000,
          0 0 3px #000;
      }

      #tooltip {
        position: absolute;
        padding: 10px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        border-radius: 5px;
        pointer-events: none;
        display: none;
        font-size: 12px;
        border: 1px solid #444;
      }

      #controls {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 5px;
        color: white;
        font-size: 12px;
      }

      #controls label {
        display: block;
        margin-bottom: 10px;
      }

      #controls input {
        margin-left: 10px;
      }

      #controls button {
        background: #444;
        color: white;
        border: 1px solid #666;
        padding: 8px 15px;
        border-radius: 3px;
        cursor: pointer;
        margin-top: 10px;
        width: 100%;
        font-size: 12px;
      }

      #controls button:hover {
        background: #555;
      }

      #simulationStatus {
        margin-top: 15px;
        padding: 8px;
        border-radius: 3px;
        text-align: center;
        font-size: 11px;
        font-weight: bold;
        transition: all 0.3s ease;
      }

      #simulationStatus.running {
        background: rgba(0, 255, 0, 0.2);
        border: 1px solid #0f0;
        color: #0f0;
      }

      #simulationStatus.stopped {
        background: rgba(255, 0, 0, 0.2);
        border: 1px solid #f00;
        color: #f00;
      }

      #simulationStatus.slowing {
        background: rgba(255, 255, 0, 0.2);
        border: 1px solid #ff0;
        color: #ff0;
      }
    </style>
  </head>
  <body>
    <div id="graph"></div>
    <div id="tooltip"></div>
    <div id="controls">
      <label>
        Link Strength:
        <input
          type="range"
          id="linkStrength"
          min="0.1"
          max="2"
          step="0.1"
          value="1"
        />
        <span id="linkStrengthValue">1</span>
      </label>
      <label>
        Charge Force:
        <input
          type="range"
          id="chargeForce"
          min="-500"
          max="-50"
          step="10"
          value="-300"
        />
        <span id="chargeForceValue">-300</span>
      </label>
      <label style="display: flex; align-items: center; margin-top: 15px">
        <input
          type="checkbox"
          id="continuousMode"
          style="margin-left: 0; margin-right: 10px"
        />
        Continuous Simulation
      </label>
      <button id="restartSimulation">Restart Simulation</button>
      <div id="simulationStatus" class="stopped">SIMULATION: STOPPED</div>
    </div>

    <script>
      const rawData = %TEMPLATE%;

      // Transform the raw graph data to visualization format
      function transformGraphData(jsonData) {
        // Create a map for quick ID to node lookup
        const nodeMap = new Map();
        jsonData.forEach((node) => {
          nodeMap.set(node.id, node);
        });

        // Calculate degree for each node (in-degree + out-degree)
        const inDegree = new Map();
        jsonData.forEach((node) => {
          // Out-degree is the length of linksTo
          node.linksTo.forEach((targetId) => {
            inDegree.set(targetId, (inDegree.get(targetId) || 0) + 1);
          });
        });

        // Transform nodes
        const nodes = jsonData.map((node) => {
          const isMulti = node.subreddit.startsWith("multi:");
          const nodeId = node.subreddit; // Use subreddit name as ID directly
          const outDegree = node.linksTo.length;
          const inDegreeCount = inDegree.get(node.id) || 0;
          const totalDegree = outDegree + inDegreeCount;

          return {
            id: nodeId,
            degree: totalDegree,
            meta: {
              nsfw: node.nsfw ? 1 : 0,
              subs: node.subscribers ?? 0, // Use 0 if null
            },
            isMulti,
          };
        });

        // Extract edges from the linksTo arrays
        const edges = [];
        jsonData.forEach((fromNode) => {
          fromNode.linksTo.forEach((toNodeId) => {
            const toNode = nodeMap.get(toNodeId);
            if (toNode) {
              const fromId = fromNode.subreddit;
              const toId = toNode.subreddit;

              // Determine if this is a multi-link
              const isMultiLink =
                fromNode.subreddit.startsWith("multi:") ||
                toNode.subreddit.startsWith("multi:");

              edges.push({
                from_subreddit: fromId,
                to_subreddit: toId,
                ...(isMultiLink ? { type: "multi-link" } : {}),
              });
            }
          });
        });

        return { nodes, edges };
      }

      // Transform the raw data
      const graphData = transformGraphData(rawData);
      console.log(`Transformed to ${graphData.nodes.length} nodes and ${graphData.edges.length} edges`);

      const width = window.innerWidth;
      const height = window.innerHeight;

      const svg = d3.select("#graph")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

      const g = svg.append("g");

      const zoom = d3.zoom()
          .scaleExtent([0.1, 10])
          .on("zoom", (event) => {
              g.attr("transform", event.transform);
          });

      svg.call(zoom);

      const getNodeColor = (d) => {
          if (d.isMulti) {
              return '#4444ff'; // Blue for multi nodes
          }
          return ['#44ff44', '#ff4444' ][d.meta.nsfw]  ;
      };

      const maxSubscribers = d3.max(graphData.nodes, d => d.meta?.subs || 0);
      const sizeScale = d3.scaleSqrt()
          .domain([0, maxSubscribers > 0 ? maxSubscribers : 10000])
          .range([5, 40]);

      const getNodeSize = (d) => {
          if (d.isMulti) {
              return sizeScale(d.meta.subs) * 1.5;
          }
          const value = d.meta.subs;
          return sizeScale(value);
      };

      const linkData = graphData.edges.map(edge => ({
          source: edge.from_subreddit,
          target: edge.to_subreddit,
          value: 1,
          type: edge.type || 'normal'
      }));

      const simulation = d3.forceSimulation(graphData.nodes)
          .force("link", d3.forceLink(linkData)
              .id(d => d.id)
              .distance(d => d.type === 'multi-link' ? 30 : 50 + 10 * Math.sqrt(d.source.degree + d.target.degree))
              .strength(d => d.type === 'multi-link' ? 1.5 : 0.3))
          .force("charge", d3.forceManyBody()
              .strength(d => -150 - 10 * Math.sqrt(d.degree || 1)))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(d => getNodeSize(d) + 3))
          .force("x", d3.forceX(width / 2).strength(0.02))
          .force("y", d3.forceY(height / 2).strength(0.02))
          .alphaDecay(0.01) // Slower decay (default ~0.0228) - simulation runs longer
          .alphaMin(0.0001) // Lower minimum alpha (default 0.001) - runs until more settled
          .velocityDecay(0.3); // Less friction (default 0.4) - smoother movement

      const link = g.append("g")
          .selectAll("line")
          .data(linkData)
          .enter().append("line")
          .attr("class", d => d.type === 'multi-link' ? 'link multi-link' : 'link');

      const node = g.append("g")
          .selectAll("circle")
          .data(graphData.nodes)
          .enter().append("circle")
          .attr("class", "node")
          .attr("r", d => getNodeSize(d))
          .attr("fill", d => getNodeColor(d))
          .call(d3.drag()
              .on("start", dragstarted)
              .on("drag", dragged)
              .on("end", dragended));

      const label = g.append("g")
          .selectAll("text")
          .data(graphData.nodes)
          .enter().append("text")
          .attr("class", "node-label")
          .text(d => d.isMulti ? d.id.replace('multi:', 'm:') : d.id)
          .style("font-size", d => Math.max(8, Math.min(getNodeSize(d) * 0.7, 14)) + "px")

      const tooltip = d3.select("#tooltip");

      node
          .on("mouseover", (event, d) => {
              // Count connections (matches degree)
              const connections = graphData.edges.filter(l =>
                  l.from_subreddit === d.id || l.to_subreddit === d.id
              ).length;

              const tooltipContent = d.isMulti ?
                  `<strong>Multi: ${d.id.replace('multi:', '')}</strong><br>
                   Subreddits: ${Math.floor(d.meta.subs / 1000)}<br>
                   Connections: ${connections}<br>
                   Degree: ${d.degree}` :
                  `<strong>r/${d.id}</strong><br>
                   Subscribers: ${d.meta.subs.toLocaleString()}<br>
                   NSFW: ${d.meta.nsfw ? 'Yes' : 'No'}<br>
                   Connections: ${connections}<br>
                   Degree: ${d.degree}`;

              tooltip
                  .style("display", "block")
                  .style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 10) + "px")
                  .html(tooltipContent);
          })
          .on("mouseout", () => {
              tooltip.style("display", "none");
          });

      // Status indicator element
      const statusIndicator = document.getElementById('simulationStatus');

      // Update simulation status
      function updateSimulationStatus() {
          const alpha = simulation.alpha();
          const alphaMin = simulation.alphaMin();

          if (alpha <= alphaMin) {
              statusIndicator.textContent = 'SIMULATION: STOPPED';
              statusIndicator.className = 'stopped';
          } else if (alpha < 0.05) {
              statusIndicator.textContent = `SIMULATION: SETTLING (α=${alpha.toFixed(4)})`;
              statusIndicator.className = 'slowing';
          } else {
              statusIndicator.textContent = `SIMULATION: RUNNING (α=${alpha.toFixed(4)})`;
              statusIndicator.className = 'running';
          }
      }

      // Update positions on tick
      simulation.on("tick", () => {
          link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => d.target.x)
              .attr("y2", d => d.target.y);

          node
              .attr("cx", d => d.x)
              .attr("cy", d => d.y);

          label
              .attr("x", d => d.x)
              .attr("y", d => d.y);

          // Update status on every tick
          updateSimulationStatus();
      });

      // Also check status periodically when simulation stops
      simulation.on("end", () => {
          updateSimulationStatus();

          // Check if continuous mode is enabled
          const continuousMode = document.getElementById('continuousMode');
          if (continuousMode.checked) {
              // Restart simulation with a moderate alpha value
              setTimeout(() => {
                  simulation.alpha(0.3).restart();
              }, 100); // Small delay to prevent immediate restart loops
          }
      });

      // Drag functions
      function dragstarted(event) {
          if (!event.active) simulation.alphaTarget(0.3).restart();
          event.subject.fx = event.subject.x;
          event.subject.fy = event.subject.y;
      }

      function dragged(event) {
          event.subject.fx = event.x;
          event.subject.fy = event.y;
      }

      function dragended(event) {
          if (!event.active) simulation.alphaTarget(0);
          event.subject.fx = null;
          event.subject.fy = null;
      }

      // Controls
      const linkStrengthSlider = document.getElementById('linkStrength');
      const linkStrengthValue = document.getElementById('linkStrengthValue');
      const chargeForceSlider = document.getElementById('chargeForce');
      const chargeForceValue = document.getElementById('chargeForceValue');

      linkStrengthSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          linkStrengthValue.textContent = value;
          simulation.force("link").strength(+value);
          simulation.alpha(0.3).restart();
      });

      chargeForceSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          chargeForceValue.textContent = value;
          simulation.force("charge").strength(+value);
          simulation.alpha(0.3).restart();
      });

      // Restart button
      const restartButton = document.getElementById('restartSimulation');
      restartButton.addEventListener('click', () => {
          simulation.alpha(1).restart(); // Full restart with alpha = 1
      });

      // Continuous mode toggle
      const continuousModeCheckbox = document.getElementById('continuousMode');
      continuousModeCheckbox.addEventListener('change', (e) => {
          if (e.target.checked && simulation.alpha() <= simulation.alphaMin()) {
              // If enabling continuous mode and simulation is stopped, restart it
              simulation.alpha(0.3).restart();
          }
      });

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
          if (e.key === 'r' || e.key === 'R') {
              // Reset zoom
              svg.transition().duration(750).call(
                  zoom.transform,
                  d3.zoomIdentity
              );
          }
      });
    </script>
  </body>
</html>
