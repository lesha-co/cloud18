<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Subreddit Network Map</title>
    <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
    <style>
      body {
        margin: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #1a1a1a;
        overflow: hidden;
      }

      #graph {
        width: 100vw;
        height: 100vh;
      }

      #controls {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 5px;
        color: white;
        font-size: 12px;
        z-index: 1000;
      }

      #controls label {
        display: block;
        margin-bottom: 10px;
      }

      #controls input {
        margin-left: 10px;
      }

      #controls button {
        background: #444;
        color: white;
        border: 1px solid #666;
        padding: 8px 15px;
        border-radius: 3px;
        cursor: pointer;
        margin-top: 10px;
        width: 100%;
        font-size: 12px;
      }

      #controls button:hover {
        background: #555;
      }

      #info {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 5px;
        color: white;
        font-size: 12px;
        max-width: 300px;
      }

      #info h3 {
        margin-top: 0;
        font-size: 14px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }

      .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 10px;
        border: 1px solid #fff;
      }
    </style>
  </head>
  <body>
    <div id="graph"></div>
    <div id="controls">
      <label>
        Link Strength:
        <input
          type="range"
          id="linkStrength"
          min="0"
          max="100"
          step="5"
          value="30"
        />
        <span id="linkStrengthValue">30</span>
      </label>
      <label>
        Charge Force:
        <input
          type="range"
          id="chargeForce"
          min="-500"
          max="-50"
          step="10"
          value="-300"
        />
        <span id="chargeForceValue">-300</span>
      </label>
      <label>
        Collision Strength:
        <input
          type="range"
          id="collisionStrength"
          min="0"
          max="2"
          step="0.1"
          value="1"
        />
        <span id="collisionStrengthValue">1</span>
      </label>
      <label>
        Link Distance:
        <input
          type="range"
          id="linkDistance"
          min="10"
          max="200"
          step="10"
          value="50"
        />
        <span id="linkDistanceValue">50</span>
      </label>
      <label style="display: flex; align-items: center; margin-top: 15px">
        <input
          type="checkbox"
          id="pauseAnimation"
          style="margin-left: 0; margin-right: 10px"
        />
        Pause Animation
      </label>
      <button id="resetCamera">Reset Camera</button>
      <button id="reheatSimulation">Reheat Simulation</button>
    </div>
    <div id="info">
      <h3>Legend</h3>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #44ff44"></div>
        <span>SFW Subreddit</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff4444"></div>
        <span>NSFW Subreddit</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #4444ff"></div>
        <span>Multi-reddit</span>
      </div>
      <div style="margin-top: 10px; font-size: 11px; color: #888">
        Node size represents subscriber count<br />
        Click nodes to highlight connections<br />
        Scroll to zoom, drag to pan
      </div>
    </div>

    <script>
      const rawData = %TEMPLATE%;

      // Transform the raw graph data to force-graph format
      function transformGraphData(jsonData) {
        // Create a map for quick ID to node lookup
        const nodeMap = new Map();
        jsonData.forEach((node) => {
          nodeMap.set(node.id, node);
        });

        // Calculate degree for each node
        const inDegree = new Map();
        jsonData.forEach((node) => {
          node.linksTo.forEach((targetId) => {
            inDegree.set(targetId, (inDegree.get(targetId) || 0) + 1);
          });
        });

        // Transform nodes
        const nodes = jsonData.map((node) => {
          const isMulti = node.subreddit.startsWith("multi:");
          const outDegree = node.linksTo.length;
          const inDegreeCount = inDegree.get(node.id) || 0;
          const totalDegree = outDegree + inDegreeCount;

          return {
            id: node.subreddit, // Use subreddit name as ID
            nodeId: node.id, // Keep numeric ID for reference
            name: node.subreddit,
            nsfw: node.nsfw ? 1 : 0,
            subscribers: node.subscribers ?? 0,
            isMulti,
            degree: totalDegree,
            val: Math.sqrt(node.subscribers ?? 1000) / 100, // Node size based on subscribers
          };
        });

        // Extract links from the linksTo arrays
        const links = [];
        jsonData.forEach((fromNode) => {
          fromNode.linksTo.forEach((toNodeId) => {
            const toNode = nodeMap.get(toNodeId);
            if (toNode) {
              const fromId = fromNode.subreddit;
              const toId = toNode.subreddit;

              // Determine if this is a multi-link
              const isMultiLink =
                fromNode.subreddit.startsWith("multi:") ||
                toNode.subreddit.startsWith("multi:");

              links.push({
                source: fromId,
                target: toId,
                isMultiLink,
                value: isMultiLink ? 2 : 1,
              });
            }
          });
        });

        return { nodes, links };
      }

      // Transform the raw data
      const graphData = transformGraphData(rawData);
      console.log(
        `Transformed to ${graphData.nodes.length} nodes and ${graphData.links.length} links`
      );

      // Create the force graph
      const elem = document.getElementById("graph");
      const Graph = new ForceGraph(elem)
        .backgroundColor("#1a1a1a")
        .nodeRelSize(6)
        .nodeVal((node) => node.val)
        .nodeColor((node) => {
          if (node.isMulti) return "#4444ff";
          return node.nsfw ? "#ff4444" : "#44ff44";
        })
        .nodeCanvasObjectMode(() => 'replace')
        .nodeCanvasObject((node, ctx, globalScale) => {
          const label = node.isMulti ? node.name.replace('multi:', 'm:') : node.name.replace('r/', '');
          const fontSize = Math.max(12, Math.min(20, 14 / Math.sqrt(globalScale)));

          // Calculate node radius
          const nodeRadius = Math.sqrt(node.val || 1) * 6;

          // Draw node circle
          ctx.beginPath();
          ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI, false);

          // Set fill color based on node type
          if (node.isMulti) {
            ctx.fillStyle = '#4444ff';
          } else {
            ctx.fillStyle = node.nsfw ? '#ff4444' : '#44ff44';
          }
          ctx.fill();

          // Draw border
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Draw text label
          ctx.font = `${fontSize}px Sans-Serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Add text shadow for better readability
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillText(label, node.x + 1, node.y + 1);

          // Draw actual text
          ctx.fillStyle = '#ffffff';
          ctx.fillText(label, node.x, node.y);
        })
        .nodeLabel((node) => {
          const connections = graphData.links.filter(
            (l) => l.source.id === node.id || l.target.id === node.id
          ).length;

          if (node.isMulti) {
            return `<div style="background: rgba(0,0,0,0.9); padding: 8px; border-radius: 4px; border: 1px solid #444;">
                      <strong>Multi: ${node.name.replace("multi:", "")}</strong><br>
                      Subreddits: ${Math.floor(node.subscribers / 1000)}<br>
                      Connections: ${connections}<br>
                      Degree: ${node.degree}
                    </div>`;
          }
          return `<div style="background: rgba(0,0,0,0.9); padding: 8px; border-radius: 4px; border: 1px solid #444;">
                    <strong>r/${node.name}</strong><br>
                    Subscribers: ${node.subscribers.toLocaleString()}<br>
                    NSFW: ${node.nsfw ? "Yes" : "No"}<br>
                    Connections: ${connections}<br>
                    Degree: ${node.degree}
                  </div>`;
        })
        .linkColor((link) => (link.isMultiLink ? "#8888ff99" : "#66666699"))
        .linkWidth((link) => (link.isMultiLink ? 2 : 1))
        .linkDirectionalParticles(1)
        .linkCurvature(0)
        .enableNodeDrag(true)
        .enableZoomPanInteraction(true)
        .d3AlphaDecay(0.01)
        .d3VelocityDecay(0.3)
        .graphData(graphData)
        .onEngineStop(() => {
          // Add collision force after the engine is initialized
          // Access d3's forceCollide through the internal d3 module
          const d3Module = window.d3 || Graph._graphData?.nodes?.[0]?.__proto__?.constructor?.d3;
          if (!d3Module) {
            // Fallback: create a simple collision detection
            Graph.d3Force("collision", (alpha) => {
              const nodes = Graph.graphData().nodes;
              const collisionPadding = 2;

              for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                  const node1 = nodes[i];
                  const node2 = nodes[j];

                  const dx = node2.x - node1.x;
                  const dy = node2.y - node1.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);

                  const radius1 = (node1.val || 1) * 6 + collisionPadding;
                  const radius2 = (node2.val || 1) * 6 + collisionPadding;
                  const minDistance = radius1 + radius2;

                  if (distance < minDistance && distance > 0) {
                    const overlap = minDistance - distance;
                    const force = overlap * alpha * 0.5;

                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;

                    node1.vx -= fx;
                    node1.vy -= fy;
                    node2.vx += fx;
                    node2.vy += fy;
                  }
                }
              }
            });
          }
        });

      // Store highlighted state
      let highlightNodes = new Set();
      let highlightLinks = new Set();
      let hoverNode = null;

      // Node click to highlight connections
      Graph.onNodeClick((node) => {
        // Clear previous highlights
        highlightNodes.clear();
        highlightLinks.clear();

        if (node) {
          highlightNodes.add(node);

          // Find connected nodes and links
          graphData.links.forEach((link) => {
            if (link.source.id === node.id) {
              highlightNodes.add(link.target);
              highlightLinks.add(link);
            } else if (link.target.id === node.id) {
              highlightNodes.add(link.source);
              highlightLinks.add(link);
            }
          });
        }

        // Update node colors
        Graph.nodeColor((n) => {
          if (highlightNodes.size === 0) {
            // No highlights, show normal colors
            if (n.isMulti) return "#4444ff";
            return n.nsfw ? "#ff4444" : "#44ff44";
          }
          // Dim non-highlighted nodes
          if (highlightNodes.has(n)) {
            if (n.isMulti) return "#4444ff";
            return n.nsfw ? "#ff4444" : "#44ff44";
          }
          return "#333333";
        });

        // Update link colors
        Graph.linkColor((link) => {
          if (highlightLinks.size === 0) {
            return link.isMultiLink ? "#8888ff" : "#666666";
          }
          if (highlightLinks.has(link)) {
            return link.isMultiLink ? "#8888ff" : "#888888";
          }
          return "#222222";
        });

        // Update link width
        Graph.linkWidth((link) => {
          if (highlightLinks.has(link)) {
            return link.isMultiLink ? 3 : 2;
          }
          return link.isMultiLink ? 2 : 1;
        });
      });

      // Node hover effects
      Graph.onNodeHover((node) => {
        hoverNode = node;
        elem.style.cursor = node ? "pointer" : "default";
      });

      // Background click to clear highlights
      Graph.onBackgroundClick(() => {
        highlightNodes.clear();
        highlightLinks.clear();

        // Reset colors
        Graph.nodeColor((node) => {
          if (node.isMulti) return "#4444ff";
          return node.nsfw ? "#ff4444" : "#44ff44";
        });

        Graph.linkColor((link) =>
          link.isMultiLink ? "#8888ff" : "#666666"
        );

        Graph.linkWidth((link) => (link.isMultiLink ? 2 : 1));
      });

      // Controls
      const linkStrengthSlider = document.getElementById("linkStrength");
      const linkStrengthValue = document.getElementById("linkStrengthValue");
      const chargeForceSlider = document.getElementById("chargeForce");
      const chargeForceValue = document.getElementById("chargeForceValue");
      const linkDistanceSlider = document.getElementById("linkDistance");
      const linkDistanceValue = document.getElementById("linkDistanceValue");
      const collisionStrengthSlider = document.getElementById("collisionStrength");
      const collisionStrengthValue = document.getElementById("collisionStrengthValue");

      linkStrengthSlider.addEventListener("input", (e) => {
        const value = e.target.value;
        linkStrengthValue.textContent = value;
        Graph.d3Force("link").strength(value / 100);
        Graph.numDimensions(3); // Trigger re-render
        Graph.numDimensions(2);
      });

      chargeForceSlider.addEventListener("input", (e) => {
        const value = e.target.value;
        chargeForceValue.textContent = value;
        Graph.d3Force("charge").strength(+value);
        Graph.numDimensions(3); // Trigger re-render
        Graph.numDimensions(2);
      });

      linkDistanceSlider.addEventListener("input", (e) => {
        const value = e.target.value;
        linkDistanceValue.textContent = value;
        Graph.d3Force("link").distance(+value);
        Graph.numDimensions(3); // Trigger re-render
        Graph.numDimensions(2);
      });

      collisionStrengthSlider.addEventListener("input", (e) => {
        const value = e.target.value;
        collisionStrengthValue.textContent = value;
        // Update collision force strength by recreating it
        Graph.d3Force("collision", (alpha) => {
          const nodes = Graph.graphData().nodes;
          const collisionPadding = 2;
          const strength = +value;

          for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
              const node1 = nodes[i];
              const node2 = nodes[j];

              const dx = node2.x - node1.x;
              const dy = node2.y - node1.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              const radius1 = (node1.val || 1) * 6 + collisionPadding;
              const radius2 = (node2.val || 1) * 6 + collisionPadding;
              const minDistance = radius1 + radius2;

              if (distance < minDistance && distance > 0) {
                const overlap = minDistance - distance;
                const force = overlap * alpha * strength * 0.5;

                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                node1.vx -= fx;
                node1.vy -= fy;
                node2.vx += fx;
                node2.vy += fy;
              }
            }
          }
        });
        Graph.d3ReheatSimulation();
      });

      // Pause animation checkbox
      const pauseAnimationCheckbox = document.getElementById("pauseAnimation");
      pauseAnimationCheckbox.addEventListener("change", (e) => {
        if (e.target.checked) {
          Graph.pauseAnimation();
        } else {
          Graph.resumeAnimation();
        }
      });

      // Reset camera button
      const resetCameraButton = document.getElementById("resetCamera");
      resetCameraButton.addEventListener("click", () => {
        Graph.centerAt(0, 0, 1000);
        Graph.zoom(1, 1000);
      });

      // Reheat simulation button
      const reheatSimulationButton =
        document.getElementById("reheatSimulation");
      reheatSimulationButton.addEventListener("click", () => {
        Graph.d3ReheatSimulation();
      });

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.key === "r" || e.key === "R") {
          // Reset zoom
          Graph.centerAt(0, 0, 1000);
          Graph.zoom(1, 1000);
        } else if (e.key === " ") {
          // Space to pause/resume
          e.preventDefault();
          pauseAnimationCheckbox.checked = !pauseAnimationCheckbox.checked;
          if (pauseAnimationCheckbox.checked) {
            Graph.pauseAnimation();
          } else {
            Graph.resumeAnimation();
          }
        }
      });
    </script>
  </body>
</html>
